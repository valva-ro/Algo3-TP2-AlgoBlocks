@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true

skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

title Diagrama de clase general

class AlgoBlocks {
    + agregarBloqueMovimientoArriba() : void
    + agregarBloqueMovimientoAbajo() : void
    + agregarBloqueMovimientoIzquierda() : void
    + agregarBloqueMovimientoDerecha() : void
    + agregarBloqueRepetirDoble() : void
    + agregarBloqueRepetirTriple() : void
    + agregarBloqueInvertir() : void
    + agregarBloqueLevantarLapiz() : void
    + agregarBloqueBajarLapiz() : void
    + ejecutar() : void
}
AlgoBlocks --> Algoritmo
AlgoBlocks --> FabricaAbstractaDeBloques
FabricaAbstractaDeBloques <|.. FabricaConcretaBloqueQueDibuja
FabricaAbstractaDeBloques <|.. FabricaConcretaBloqueQueNoDibuja
interface FabricaAbstractaDeBloques {
    + {abstract} crearBloqueMovimientoArriba() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoAbajo() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoDerecha() : BloqueMovimiento
}
class FabricaConcretaBloqueQueDibuja {
    + crearBloqueMovimientoArriba() : BloqueMovimiento
    + crearBloqueMovimientoAbajo() : BloqueMovimiento
    + crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + crearBloqueMovimientoDerecha() : BloqueMovimiento
}
class FabricaConcretaBloqueQueNoDibuja {
    + crearBloqueMovimientoArriba() : BloqueMovimiento
    + crearBloqueMovimientoAbajo() : BloqueMovimiento
    + crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + crearBloqueMovimientoDerecha() : BloqueMovimiento
}

interface Bloque {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
    + {abstract} invertir() : void
}

class SectorDibujo {
    + dibujar(unMovimiento) : void
    + obtenerMovimientosDibujados() : Estructura<Movimiento>
}

interface Movimiento {
    + {abstract} estaDibujado() : boolean
}

class Algoritmo {
    + agregarBloque(unBloque : Bloque) : void
    + sacar(unBloque : Bloque) : void
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
Algoritmo "1" o-- "0..*" Bloque
Bloque ..down> SectorDibujo
SectorDibujo "1" o-- "1..*" Movimiento
@enduml




@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}
skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

interface Bloque {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
}
class BloqueMovimiento {
    + BloqueMovimiento(movimiento : Movimiento)
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
interface Bloques {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}
class BloquePersonalizado {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
note bottom of BloquePersonalizado
for cadaBloque in Bloques:
    cadaBloque.ejecutar()
end note
class RepetirDoble {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
note bottom of RepetirDoble
super.ejecutar() x2
end note
class RepetirTriple {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
note bottom of RepetirTriple
super.ejecutar() x3
end note
class Invertir {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
note bottom of Invertir
for cadaBloque in Bloques:
    cadaBloque.invertir()
super.ejecutar()
end note
abstract class Movimiento {
    + Movimiento(estado : Estado)
    + {abstract} estaDibujado() : boolean
}
class Arriba {
    + estaDibujado() : boolean
}
class Abajo {
    + estaDibujado() : boolean
}
class Derecha {
    + estaDibujado() : boolean
}
class Izquierda {
    + estaDibujado() : boolean
}
class DecoratorBloquePersonalizadoBase {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}
note right
objetoQueEnvuelve.ejecutar()
end note
note right
Envuelve solo UN objeto!
Puede ser un BloquePersonalizado,
un RepetirDoble, RepetirTriple o
Invertir. Cada uno de los ultimos
tiene que envolver a su vez otro
hasta llegar a la utilma capa
que serÃ­a quien envuelve a
BloquePersonalizado
end note
interface Estado {
    + {abstract} estaDibujado() : boolean
}
class Dibuja {
    + estaDibujado() : boolean
}
class NoDibuja {
    + estaDibujado() : boolean
}

interface FabricaAbstractaDeBloques {
    + {abstract} crearBloqueMovimientoArriba() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoAbajo() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoDerecha() : BloqueMovimiento
}
FabricaAbstractaDeBloques ..left> BloqueMovimiento

Movimiento *-- Estado
Estado <|.. Dibuja
Estado <|.. NoDibuja
Bloque <|.. Bloques
Bloques "1" *-- "1..*" Bloque
Bloques <|-- BloquePersonalizado
Bloques <|-- DecoratorBloquePersonalizadoBase
DecoratorBloquePersonalizadoBase o-- Bloques
DecoratorBloquePersonalizadoBase <|-- RepetirDoble
DecoratorBloquePersonalizadoBase <|-- RepetirTriple
DecoratorBloquePersonalizadoBase <|-- Invertir
Bloque <|.. BloqueMovimiento

BloqueMovimiento *--left Movimiento
Movimiento <|.. Arriba
Movimiento <|.. Abajo
Movimiento <|.. Derecha
Movimiento <|.. Izquierda
@enduml