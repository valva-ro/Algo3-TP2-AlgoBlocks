@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true

skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

title Diagrama de clase general

class AlgoBlocks {
    + agregarBloqueMovimientoArriba() : void
    + agregarBloqueMovimientoAbajo() : void
    + agregarBloqueMovimientoIzquierda() : void
    + agregarBloqueMovimientoDerecha() : void
    + agregarBloqueRepetirDoble() : void
    + agregarBloqueRepetirTriple() : void
    + agregarBloqueInvertir() : void
    + agregarBloqueLevantarLapiz() : void
    + agregarBloqueBajarLapiz() : void
    + ejecutar() : void
}

interface FabricaAbstractaDeBloques {
    + {abstract} crearBloqueMovimientoArriba() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoAbajo() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + {abstract} crearBloqueMovimientoDerecha() : BloqueMovimiento
}
class FabricaConcretaBloqueQueDibuja {
    + crearBloqueMovimientoArriba() : BloqueMovimiento
    + crearBloqueMovimientoAbajo() : BloqueMovimiento
    + crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + crearBloqueMovimientoDerecha() : BloqueMovimiento
}
class FabricaConcretaBloqueQueNoDibuja {
    + crearBloqueMovimientoArriba() : BloqueMovimiento
    + crearBloqueMovimientoAbajo() : BloqueMovimiento
    + crearBloqueMovimientoIzquierda() : BloqueMovimiento
    + crearBloqueMovimientoDerecha() : BloqueMovimiento
}

interface Bloque {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
    + {abstract} invertir() : void
}

class Algoritmo {
    + agregar(unBloque : Bloque) : void
    + sacar(unBloque : Bloque) : void
    + ejecutar(unSectorDibujo : SectorDibujo) : void
}

Algoritmo "1" o-- "0..*" Bloque

AlgoBlocks -> Algoritmo
AlgoBlocks --> FabricaAbstractaDeBloques
FabricaAbstractaDeBloques <|.. FabricaConcretaBloqueQueDibuja
FabricaAbstractaDeBloques <|.. FabricaConcretaBloqueQueNoDibuja
@enduml


@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true

skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

title Diagrama de clase general


class SectorDibujo {
    + invertirDibuja() : void
    + dibujar(direccion : Direccion) : void
    + existe(posicion : Posicion) : boolean
}
class Recorrido {
    + agregarArista(direccion : Direccion, recorridoTotal : Recorrido) : void
    + existeVertice(posicion : Posicion) : boolean
    + existeArista(origen : Posicion, destino : Posicion) : boolean
}

class Arista {
    + contiene(posicion : Posicion) : boolean
}

class Posicion {
    - coordenadaX : int
    - coordenadaY : int
    + contiene(posicion : Posicion) : boolean
    + actualizar(direccion : Direccion) : Posicion
}

SectorDibujo "1" *-- "2" Recorrido
Recorrido "1" *-- "1..*" Arista
Arista "1" *-- "2" Posicion
@enduml


@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}
skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

title Diagrama de clase de Bloque y BloqueMovimiento

interface Bloque {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
    + {abstract} ejecutarInvertido(unSectorDibujo : SectorDibujo) : void

}
class BloqueMovimiento {
    + BloqueMovimiento(direccion : Direccion, estado : Estado)
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
}
interface Estado {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo, direccion : Direccion)
}
class Dibuja {
    + ejecutar(unSectorDibujo : SectorDibujo, direccion : Direccion)
}
class NoDibuja {
    + ejecutar(unSectorDibujo : SectorDibujo, direccion : Direccion)
}
abstract class Direccion {
    + actualizarPosicion(posicion : Posicion) : Posicion
    + {abstract} invertir() : Direccion
}
class Norte {
    + invertir() : Sur
}
class Sur {
    + invertir() : Norte
}
class Este {
    + invertir() : Oeste
}
class Oeste {
    + invertir() : Este
}

Bloque <|.. BloqueMovimiento
BloqueMovimiento *-- Estado
Estado <|.. Dibuja
Estado <|.. NoDibuja
BloqueMovimiento *--right Direccion
Direccion <|-- Norte
Direccion <|-- Sur
Direccion <|-- Este
Direccion <|-- Oeste
@enduml




@startuml
hide circle
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam class {
    ArrowColor DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}
skinparam note {
    BackgroundColor LightYellow
    BorderColor DarkBlue
}

title Diagrama de clase de Bloque y bloques especiales

interface Bloque {
    + {abstract} ejecutar(unSectorDibujo : SectorDibujo) : void
    + {abstract} ejecutarInvertido(unSectorDibujo : SectorDibujo) : void

}
class BloqueMovimiento {
    + BloqueMovimiento(direccion : Direccion)
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
}
interface Bloques {
    + {abstract} agregar(unBloque : bloque) : void
}
class BloquePersonalizado {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}
class RepetirDoble {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}
class RepetirTriple {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}
class Invertir {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}
class DecoratorBloquePersonalizadoBase {
    + ejecutar(unSectorDibujo : SectorDibujo) : void
    + ejecutarInvertido(unSectorDibujo : SectorDibujo) : void
    + agregar(unBloque : bloque) : void
}

Bloque <|.. Bloques
Bloques "1" *-- "1..*" Bloque
Bloques <|.. BloquePersonalizado
Bloques <|.. DecoratorBloquePersonalizadoBase
DecoratorBloquePersonalizadoBase o-- Bloques
DecoratorBloquePersonalizadoBase <|-- RepetirDoble
DecoratorBloquePersonalizadoBase <|-- RepetirTriple
DecoratorBloquePersonalizadoBase <|-- Invertir
Bloque <|.. BloqueMovimiento
@enduml



@startuml
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam ArrowColor DarkBlue
skinparam SequenceLifeLineBorderColor DarkBlue
skinparam SequenceLoopBackgroundColor DarkBlue

skinparam actor {
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam participant {
    Bound DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

title Ejecución de un algoritmo con bloques de movimiento

participant ":Algoritmo" as Algoritmo
participant ":BloqueMovimiento" as Bloque
participant ":SectorDibujo" as SectorDibujo

Algoritmo -> Algoritmo : ejecutar(unSectorDibujo)
loop para cada bloque
    Algoritmo -> Bloque : ejecutar(unSectorDibujo)
    Bloque -> SectorDibujo : dibuja(unMovimiento)
end
@enduml



@startuml
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam ArrowColor DarkBlue
skinparam SequenceLifeLineBorderColor DarkBlue
skinparam SequenceLoopBackgroundColor DarkBlue

skinparam actor {
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam participant {
    Bound DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

title Ejecución de un algoritmo con un solo bloque de repetición doble que tiene bloques de movimiento

participant ":Algoritmo" as Algoritmo
participant ":BloqueRepeticionDoble" as BloqueRepetirDoble
participant ":DecoratorBloquePersonalizadoBase" as DecoratorBloquePersonalizadoBase
participant ":BloquePersonalizado" as BloquePersonalizado
participant ":BloqueMovimiento" as BloqueMovimiento
participant ":SectorDibujo" as SectorDibujo

Algoritmo -> Algoritmo : ejecutar(unSectorDibujo)
Algoritmo -> BloqueRepetirDoble : ejecutar(unSectorDibujo)
loop x2
    BloqueRepetirDoble -> DecoratorBloquePersonalizadoBase : ejecutar(unSectorDibujo)
    DecoratorBloquePersonalizadoBase ->  BloquePersonalizado : ejecutar(unSectorDibujo)
    loop para cada bloque dentro de BloquePersonalizado
        BloquePersonalizado -> BloqueMovimiento : ejecutar(unSectorDibujo)
        BloqueMovimiento -> SectorDibujo : dibuja(unMovimiento)
    end loop
end loop
@enduml



@startuml
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam ArrowColor DarkBlue
skinparam SequenceLifeLineBorderColor DarkBlue
skinparam SequenceLoopBackgroundColor DarkBlue

skinparam actor {
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam participant {
    Bound DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

title Ejecución de un algoritmo con un bloque invertir que tiene bloques de movimiento

participant ":Algoritmo" as Algoritmo
participant ":BloqueInvertir" as BloqueInvertir
participant ":DecoratorBloquePersonalizadoBase" as DecoratorBloquePersonalizadoBase
participant ":BloquePersonalizado" as BloquePersonalizado
participant ":BloqueMovimiento" as BloqueMovimiento
participant "Movimiento" as Movimiento
participant ":SectorDibujo" as SectorDibujo

Algoritmo -> Algoritmo : ejecutar(unSectorDibujo)
Algoritmo -> BloqueInvertir : ejecutar(unSectorDibujo)
BloqueInvertir -> DecoratorBloquePersonalizadoBase : ejecutarInvertido(unSectorDibujo)
DecoratorBloquePersonalizadoBase ->  BloquePersonalizado : ejecutarInvertido(unSectorDibujo)
loop para cada bloque dentro de BloquePersonalizado
    BloquePersonalizado -> BloqueMovimiento : ejecutarInvertido(unSectorDibujo)
    BloqueMovimiento -> Movimiento : invertir()
    Movimiento --> BloqueMovimiento : unMovimientoInvertido
    BloqueMovimiento -> SectorDibujo : dibuja(unMovimientoInvertido)
end loop
@enduml



@startuml
skinparam classAttributeIconSize 0
skinparam backgroundColor White
skinparam RoundCorner 10
skinparam Shadowing true
skinparam ArrowColor DarkBlue
skinparam SequenceLifeLineBorderColor DarkBlue
skinparam SequenceLoopBackgroundColor DarkBlue

skinparam actor {
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

skinparam participant {
    Bound DarkBlue
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

title Ejecución de un algoritmo con un bloque invertir que tiene un bloque de movimiento hacia arriba

participant ":Algoritmo" as Algoritmo
participant ":BloqueInvertir" as BloqueInvertir
participant ":DecoratorBloquePersonalizadoBase" as DecoratorBloquePersonalizadoBase
participant ":BloquePersonalizado" as BloquePersonalizado
participant ":BloqueMovimiento" as BloqueMovimiento
participant ":Arriba" as Arriba
participant ":Abajo" as Abajo
participant ":SectorDibujo" as SectorDibujo

Algoritmo -> Algoritmo : ejecutar(unSectorDibujo)
Algoritmo -> BloqueInvertir : ejecutar(unSectorDibujo)
BloqueInvertir -> DecoratorBloquePersonalizadoBase : ejecutarInvertido(unSectorDibujo)
DecoratorBloquePersonalizadoBase ->  BloquePersonalizado : ejecutarInvertido(unSectorDibujo)
loop para cada bloque dentro de BloquePersonalizado
    BloquePersonalizado -> BloqueMovimiento : ejecutarInvertido(unSectorDibujo)
    BloqueMovimiento -> Arriba : invertir()
    Arriba -> Abajo : new
    Abajo --> Arriba : unAbajo
    Arriba --> BloqueMovimiento : unAbajo
    BloqueMovimiento -> SectorDibujo : dibuja(unAbajo)
end loop
@enduml